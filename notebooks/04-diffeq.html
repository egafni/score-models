<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.340">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>A Pedagogical Introduction to Score Models - 5&nbsp; Differential Equations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../notebooks/05-generalizing-2d.html" rel="next">
<link href="../notebooks/03-noise-scales.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../notebooks/04-diffeq.html"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Differential Equations</span></a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">A Pedagogical Introduction to Score Models</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">A Pedagogical Introduction to Score Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/01-score-function.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Score Functions</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/02-langevin-dynamics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Langevin Dynamics</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/03-noise-scales.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Noise Scales</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/04-diffeq.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Differential Equations</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/05-generalizing-2d.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Generalizing to Higher Dimensions</span></span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#ordinary-differential-equations" id="toc-ordinary-differential-equations" class="nav-link active" data-scroll-target="#ordinary-differential-equations"><span class="header-section-number">5.1</span> Ordinary differential equations</a>
  <ul class="collapse">
  <li><a href="#a-classic-ode-example" id="toc-a-classic-ode-example" class="nav-link" data-scroll-target="#a-classic-ode-example"><span class="header-section-number">5.1.1</span> A classic ODE example</a></li>
  </ul></li>
  <li><a href="#stochastic-differential-equations" id="toc-stochastic-differential-equations" class="nav-link" data-scroll-target="#stochastic-differential-equations"><span class="header-section-number">5.2</span> Stochastic Differential Equations</a>
  <ul class="collapse">
  <li><a href="#noisy-decay" id="toc-noisy-decay" class="nav-link" data-scroll-target="#noisy-decay"><span class="header-section-number">5.2.1</span> Noisy Decay</a></li>
  <li><a href="#oscillating-sde" id="toc-oscillating-sde" class="nav-link" data-scroll-target="#oscillating-sde"><span class="header-section-number">5.2.2</span> Oscillating SDE</a></li>
  <li><a href="#noising-sde" id="toc-noising-sde" class="nav-link" data-scroll-target="#noising-sde"><span class="header-section-number">5.2.3</span> Noising SDE</a></li>
  </ul></li>
  <li><a href="#reverse-time-sdes" id="toc-reverse-time-sdes" class="nav-link" data-scroll-target="#reverse-time-sdes"><span class="header-section-number">5.3</span> Reverse Time SDEs</a></li>
  <li><a href="#continuous-time-score-models" id="toc-continuous-time-score-models" class="nav-link" data-scroll-target="#continuous-time-score-models"><span class="header-section-number">5.4</span> Continuous Time Score Models</a>
  <ul class="collapse">
  <li><a href="#model-implementation" id="toc-model-implementation" class="nav-link" data-scroll-target="#model-implementation"><span class="header-section-number">5.4.1</span> Model implementation</a></li>
  <li><a href="#loss-function" id="toc-loss-function" class="nav-link" data-scroll-target="#loss-function"><span class="header-section-number">5.4.2</span> Loss function</a></li>
  <li><a href="#train-score-model" id="toc-train-score-model" class="nav-link" data-scroll-target="#train-score-model"><span class="header-section-number">5.4.3</span> Train score model</a></li>
  <li><a href="#sanity-check-score-estimators-match-up-with-alternate-calculation" id="toc-sanity-check-score-estimators-match-up-with-alternate-calculation" class="nav-link" data-scroll-target="#sanity-check-score-estimators-match-up-with-alternate-calculation"><span class="header-section-number">5.4.4</span> Sanity-check: score estimators match up with alternate calculation</a></li>
  </ul></li>
  <li><a href="#probability-flow-odes" id="toc-probability-flow-odes" class="nav-link" data-scroll-target="#probability-flow-odes"><span class="header-section-number">5.5</span> Probability Flow ODEs</a></li>
  <li><a href="#generalizing-to-a-mixture-distribution" id="toc-generalizing-to-a-mixture-distribution" class="nav-link" data-scroll-target="#generalizing-to-a-mixture-distribution"><span class="header-section-number">5.6</span> Generalizing to a Mixture Distribution</a>
  <ul class="collapse">
  <li><a href="#generate-mixture-data" id="toc-generate-mixture-data" class="nav-link" data-scroll-target="#generate-mixture-data"><span class="header-section-number">5.6.1</span> Generate Mixture Data</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">5.7</span> References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Differential Equations</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>We’re going to take a small detour through ordinary differential equations (ODEs). ODEs, and their stochastic counterparts, Stochastic Differential Equations (SDEs), are an important technical advance in score-based generative modelling. In this section, we’re going to see how to use SDEs to noise up data, thereby replacing the noising step, and reverse-time versions of the SDEs to generate new data, thereby replacing the annealed Langevin dynamics step.</p>
<section id="ordinary-differential-equations" class="level2" data-number="5.1">
<h2 data-number="5.1" class="anchored" data-anchor-id="ordinary-differential-equations"><span class="header-section-number">5.1</span> Ordinary differential equations</h2>
<p>Let’s start with ODEs. ODEs are usually taught in undergraduate calculus classes, since they involve differentiation and integration. I do remember encountering them while studying in secondary school and junior college in Singapore, which is a testament to how advanced the mathematics curriculum in Singapore is.</p>
<p>ODEs are useful models of systems where we believe that the rate of change of an output variable is a math function of some input variable. In abstract mathematical symbols:</p>
<p><span class="math display">\[\frac{dy}{dx} = f(x, \theta)\]</span></p>
<p>Here, <span class="math inline">\(f\)</span> simply refers to some mathematical function of <span class="math inline">\(x\)</span> and the function’s parameters <span class="math inline">\(\theta\)</span>.</p>
<section id="a-classic-ode-example" class="level3" data-number="5.1.1">
<h3 data-number="5.1.1" class="anchored" data-anchor-id="a-classic-ode-example"><span class="header-section-number">5.1.1</span> A classic ODE example</h3>
<p>A classic ODE example that we might think of is that of a decay curve:</p>
<p><span class="math display">\[\frac{dy}{dt} = -y\]</span></p>
<p>Implemented in <code>diffrax</code>, which is a JAX package for differential equations, and wrapped in Equinox as a parameterized function, we have the following code:</p>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> diffrax <span class="im">import</span> diffeqsolve, Tsit5, ODETerm, SaveAt</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> jax.numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> vmap</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> equinox <span class="im">as</span> eqx</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exponential_decay_drift(t: <span class="bu">float</span>, y: <span class="bu">float</span>, args: <span class="bu">tuple</span>):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Exponential decay drift term."""</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span>y</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> score_models.models.ode <span class="im">import</span> ODE</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> inspect <span class="im">import</span> getsource </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(getsource(ODE))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>class ODE(eqx.Module):
    """Equinox ODE module.

    Wraps a very common ODE code pattern into a single object.
    """

    drift: callable

    def __call__(self, ts: np.ndarray, y0: float) -&gt; np.ndarray:
        """Solve an ODE model.

        :param ts: Time steps to follow through.
        :param y0: Initial value.
        :returns: The trajectory starting from y0.
        """
        term = ODETerm(self.drift)
        solver = Tsit5()
        saveat = SaveAt(ts=ts, dense=True)
        sol = diffeqsolve(
            term, solver, t0=ts[0], t1=ts[-1], dt0=ts[1] - ts[0], y0=y0, saveat=saveat
        )
        return vmap(sol.evaluate)(ts)
</code></pre>
</div>
</div>
<p>For those of us who have learned about ODEs, the structure of the code above should look pretty familiar. The diffrax API neatly organizes what we need to solve ODEs:</p>
<ul>
<li>the <code>ODETerm</code>, which is the <span class="math inline">\(\frac{dy}{dt}\)</span> equation,</li>
<li>a <code>solver</code>, for which <code>diffrax</code> provides a library of them,</li>
<li>the initial and end points <span class="math inline">\(t_0\)</span> and <span class="math inline">\(t_1\)</span> along the <span class="math inline">\(t\)</span> axis along with step size <span class="math inline">\(dt\)</span>,</li>
<li>the initial value of <span class="math inline">\(y\)</span>, i.e.&nbsp;<span class="math inline">\(y_0\)</span>.</li>
</ul>
<p>Finally, when calling on the ODE, we evaluate the solution path from the starting time to the ending time, given an initial starting value.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>ode <span class="op">=</span> ODE(exponential_decay_drift)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>ts <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">10</span>, <span class="dv">1000</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>ys <span class="op">=</span> ode(ts<span class="op">=</span>ts, y0<span class="op">=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>plt.plot(ts, ys)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"t"</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"y"</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-ode-exponential-decay" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-ode-exponential-decay-output-1.png" width="589" height="429" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.1: Solution to the ODE <span class="math inline">\(f'(y) = -y\)</span>.</figcaption>
</figure>
</div>
</div>
</div>
<p>The solution of the ODE that we had above is an exponential decay, and that is exactly what we see in the curve above.</p>
<p>And if we wanted to run the ODE from multiple starting points:</p>
<div class="cell" data-execution_count="5">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>ys <span class="op">=</span> ode(ts<span class="op">=</span>ts, y0<span class="op">=</span>np.arange(<span class="op">-</span><span class="dv">10</span>, <span class="dv">10</span>))</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> curve <span class="kw">in</span> ys.T:</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    plt.plot(ts, curve, color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"t"</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"y"</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-ode-multiple-decay" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-ode-multiple-decay-output-1.png" width="609" height="429" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.2: Multiple solutions to the ODE <span class="math inline">\(f'(y) = -y\)</span>.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="stochastic-differential-equations" class="level2" data-number="5.2">
<h2 data-number="5.2" class="anchored" data-anchor-id="stochastic-differential-equations"><span class="header-section-number">5.2</span> Stochastic Differential Equations</h2>
<p>Stochastic differential equations (SDEs) extend ODEs by adding in noise into each step. SDEs can thus be thought of as having a “drift” component, in which the system being modeled by the SDE “drifts” through the vector field, and a “diffusion” component, in which the system’s state is perturbed with additional noise. SDEs have the general form:</p>
<p><span class="math display">\[dx = f(x, t)dt + g(t)dw\]</span></p>
<p>To paraphrase Yang’s blog post, here are the definitions of each of the terms.</p>
<ul>
<li><span class="math inline">\(f(x, t)\)</span> is a drift function that produces a vector output, i.e.&nbsp;what would have been the ODE term. This term controls the “drift”-ing of the system in observed data space.</li>
<li><span class="math inline">\(g(t)\)</span> is a diffusion function that produces a scalar output, i.e.&nbsp;the scalar multiplier of <span class="math inline">\(dw\)</span>. This term adds “diffusive” noise to the output.</li>
<li><span class="math inline">\(dw\)</span> is the infinitesimal white noise term.</li>
</ul>
<p><span class="math inline">\(f(x, t)dt\)</span> is usually referred to as the “ODE Term”, while <span class="math inline">\(g(t)dw\)</span> is usually referred to as the “Control Term”. We can see that in the implementation of the SDE module below.</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> score_models.models.sde <span class="im">import</span> SDE</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(getsource(SDE))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>class SDE(eqx.Module):
    """Equinox SDE module.

    Wraps a very common SDE code pattern into a single object.
    """

    drift: callable
    diffusion: callable

    def __call__(self, ts: np.ndarray, y0: float, key: random.PRNGKey) -&gt; np.ndarray:
        """Solve an SDE model.

        :param ts: Time steps to follow through.
        :param y0: Initial value.
        :param key: PRNG key for reproducibility purposes.
        :returns: The trajectory starting from y0.
        """
        brownian_motion = VirtualBrownianTree(
            ts[0], ts[-1], tol=1e-3, shape=(), key=key
        )
        terms = MultiTerm(
            ODETerm(self.drift), ControlTerm(self.diffusion, brownian_motion)
        )
        solver = Heun()
        saveat = SaveAt(t0=True, ts=ts, dense=True)
        sol = diffeqsolve(
            terms, solver, t0=ts[0], t1=ts[-1], dt0=ts[1] - ts[0], y0=y0, saveat=saveat
        )
        return vmap(sol.evaluate)(ts)
</code></pre>
</div>
</div>
<section id="noisy-decay" class="level3" data-number="5.2.1">
<h3 data-number="5.2.1" class="anchored" data-anchor-id="noisy-decay"><span class="header-section-number">5.2.1</span> Noisy Decay</h3>
<p>For illustration, let’s see what happens we we apply homoskedastic noise to the decay process. Here, homoskedastic noise refers to a noise term that is <em>independent</em> of time. Firstly, we have it defined in code.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> homoskedastic_diffusion(t, y, args):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Time-independent noise."""</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">0.3</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we set up the SDE and solve it going forward in time.</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> random </span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>n_timesteps <span class="op">=</span> <span class="dv">17</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>n_starting <span class="op">=</span> <span class="dv">1001</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>demo_key <span class="op">=</span> random.PRNGKey(<span class="dv">55</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>y0_key, key <span class="op">=</span> random.split(demo_key)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>y0s <span class="op">=</span> random.normal(y0_key, shape<span class="op">=</span>(n_starting,))  <span class="co"># We solve the SDE for each draw from a Guassian.</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>sde_keys <span class="op">=</span> random.split(key, <span class="bu">len</span>(y0s))</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>ts <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">4</span>, n_timesteps)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>sde <span class="op">=</span> SDE(drift<span class="op">=</span>exponential_decay_drift, diffusion<span class="op">=</span>homoskedastic_diffusion)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>sde <span class="op">=</span> partial(sde, ts)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>ys <span class="op">=</span> vmap(sde)(y0s, sde_keys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, let’s plot the trajectories:</p>
<div class="cell" data-execution_count="9">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y <span class="kw">in</span> ys:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    plt.plot(ts, y, alpha<span class="op">=</span><span class="fl">0.01</span>, color<span class="op">=</span><span class="st">"blue"</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"t"</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"y"</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-sde-decay-homoskedastic" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-sde-decay-homoskedastic-output-1.png" width="587" height="429" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.3: SDE with exponential decay drift and homoskedastic disffusion.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="oscillating-sde" class="level3" data-number="5.2.2">
<h3 data-number="5.2.2" class="anchored" data-anchor-id="oscillating-sde"><span class="header-section-number">5.2.2</span> Oscillating SDE</h3>
<p>Let’s do another example: oscillating SDEs! Here, we have an oscillating system (cosine drift) in which we add a homoskedastic diffusion term.</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cosine_drift(t, y, args):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.cos(t)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>sde <span class="op">=</span> SDE(drift<span class="op">=</span>cosine_drift, diffusion<span class="op">=</span>homoskedastic_diffusion)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>ts_oscillating <span class="op">=</span> np.linspace(<span class="dv">1</span>, <span class="dv">10</span>, n_timesteps)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>sde <span class="op">=</span> partial(sde, ts_oscillating)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>keys <span class="op">=</span> random.split(key, <span class="dv">1001</span>)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>oscillating_y0s <span class="op">=</span> random.normal(key, shape<span class="op">=</span>(<span class="dv">1001</span>,)) <span class="op">*</span> <span class="fl">0.1</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>oscillating_ys <span class="op">=</span> vmap(sde)(oscillating_y0s, keys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Likewise, let’s plot this one too:</p>
<div class="cell" data-execution_count="11">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y <span class="kw">in</span> oscillating_ys:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    plt.plot(ts_oscillating, y, color<span class="op">=</span><span class="st">"blue"</span>, alpha<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"t"</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"y"</span>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-sde-oscillating-homoskedastic" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-sde-oscillating-homoskedastic-output-1.png" width="587" height="429" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.4: SDE with exponential decay drift and homoskedastic disffusion.</figcaption>
</figure>
</div>
</div>
</div>
<p>At each timepoint, there is also a marginal distribution. Let’s inspect that below.</p>
<div class="cell" data-execution_count="12">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> onp</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">10</span>), nrows<span class="op">=</span><span class="dv">6</span>, ncols<span class="op">=</span><span class="dv">3</span>, sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> axes.flatten()</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, t, y <span class="kw">in</span> <span class="bu">zip</span>(axes, ts_oscillating, oscillating_ys.T):</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    plt.sca(ax)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    plt.hist(onp.array(y), bins<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f"time=</span><span class="sc">{</span>t<span class="sc">:.1f}</span><span class="ss">"</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>sns.despine()</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>plt.delaxes(axes[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-sde-oscillating-marginals" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-sde-oscillating-marginals-output-1.png" width="758" height="949" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.5: Marginal distribution at each time point of the oscillating SDE.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="noising-sde" class="level3" data-number="5.2.3">
<h3 data-number="5.2.3" class="anchored" data-anchor-id="noising-sde"><span class="header-section-number">5.2.3</span> Noising SDE</h3>
<p>For the purposes of noising up date, we would want an SDE that noises up data with increasing amounts of noise with time. Here, we can design the SDE such that the drift would be 0 at all time points, while the diffusion term would be some multiplier on time.</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> constant_drift(t, y, args):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Constant drift term."""</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> time_dependent_diffusion(t, y, args):</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Diffusion term that increases with time."""</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">0.3</span> <span class="op">*</span> t</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As always, we set up the SDE:</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>sde <span class="op">=</span> SDE(drift<span class="op">=</span>constant_drift, diffusion<span class="op">=</span>time_dependent_diffusion)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>ts_noising <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">4</span>, n_timesteps)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>sde <span class="op">=</span> partial(sde, ts_noising)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>y0s <span class="op">=</span> random.normal(key, shape<span class="op">=</span>(n_starting,)) <span class="op">*</span> <span class="fl">0.1</span>  <span class="co"># we start with N(0, 0.1) draws.</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>keys <span class="op">=</span> random.split(key, n_starting)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>noising_ys <span class="op">=</span> vmap(sde)(y0s, keys)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then let’s plot the solved SDE trajectories:</p>
<div class="cell" data-execution_count="15">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y <span class="kw">in</span> noising_ys:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    plt.plot(ts_noising, y, color<span class="op">=</span><span class="st">"blue"</span>, alpha<span class="op">=</span><span class="fl">0.01</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"t"</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"y"</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f"</span><span class="sc">{</span>n_starting<span class="sc">}</span><span class="ss"> sample trajectories"</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-noising-sde" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-noising-sde-output-1.png" width="587" height="449" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.6: A “noising” SDE that progressively adds more noise over time.</figcaption>
</figure>
</div>
</div>
</div>
<p>As we can see above, we are able to obtain greater amounts of noise from a tight starting point. We can verify that by looking at the marginal distributions.</p>
<div class="cell" data-execution_count="16">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> onp</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">10</span>), nrows<span class="op">=</span><span class="dv">6</span>, ncols<span class="op">=</span><span class="dv">3</span>, sharex<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>axes <span class="op">=</span> axes.flatten()</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, t, y <span class="kw">in</span> <span class="bu">zip</span>(axes, ts_noising, noising_ys.T):</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    plt.sca(ax)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    plt.hist(onp.array(y), bins<span class="op">=</span><span class="dv">30</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f"time=</span><span class="sc">{</span>t<span class="sc">:.1f}</span><span class="ss">, σ=</span><span class="sc">{</span>onp<span class="sc">.</span>std(y)<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>sns.despine()</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>plt.delaxes(axes[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-sde-noising-marginals" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-sde-noising-marginals-output-1.png" width="758" height="949" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.7: Marginal distribution at each time point of a noising SDE.</figcaption>
</figure>
</div>
</div>
</div>
<p>From the marginal distributions at each noise timestep, we see that we indeed have ever increasing amounts of noise. (Note how the x-axis scale is the same on all of the plots.) The empirical standard deviation from the mean is also shown on the plots above.</p>
</section>
</section>
<section id="reverse-time-sdes" class="level2" data-number="5.3">
<h2 data-number="5.3" class="anchored" data-anchor-id="reverse-time-sdes"><span class="header-section-number">5.3</span> Reverse Time SDEs</h2>
<p>With constant drift and time-dependent diffusion, we can noise up data in a continuous fashion. How do we go backwards? Here is where solving the reverse time SDE will come in. Again, we need to set up the drift and diffusion terms. Here, the drift term is:</p>
<p><span class="math display">\[f(x, t) - g^2(t) \nabla_x \log p_t (x) \]</span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(f(x, t)\)</span> is the drift term of the forward SDE,</li>
<li><span class="math inline">\(g(t)\)</span> is the diffusion term of the forward SDE, and</li>
<li><span class="math inline">\(\nabla_x \log p_t (x)\)</span> is the score function of the data.</li>
</ul>
<p>And the diffusion term is:</p>
<p><span class="math display">\[g(t) dw\]</span></p>
<p>which is basically the diffusion term of the forward SDE.</p>
<p>However, the tricky part here is that we don’t have access to <span class="math inline">\(\nabla_x \log p_t (x)\)</span> (the true score function). As such, we need to bring out our score model approximator! To train the score model approximator, we need the analogous score matching objective for continuous time problems.</p>
</section>
<section id="continuous-time-score-models" class="level2" data-number="5.4">
<h2 data-number="5.4" class="anchored" data-anchor-id="continuous-time-score-models"><span class="header-section-number">5.4</span> Continuous Time Score Models</h2>
<p>In an ideal situation, we would train the score matching model using a weighted combination of Fisher divergences:</p>
<p><span class="math display">\[\mathbb{E}_{t \in U(0, T)} \mathbb{E}_{p_t(x)} [ \lambda(t) || \nabla_x \log p_t(x) - s_{\theta}(x, t) ||^2_2]\]</span></p>
<p>Now, just like before, we don’t have access to <span class="math inline">\(\nabla_x \log p_t (x)\)</span>, so we instead use the score matching objective by Hyvärinen <span class="citation" data-cites="JMLR:v6:hyvarinen05a">(<a href="#ref-JMLR:v6:hyvarinen05a" role="doc-biblioref">Hyvärinen 2005</a>)</span>. What’s really cool here is that we can train the models using the noised up data. The protocol is basically as follows:</p>
<ol type="1">
<li>Noise up our original data using an SDE.</li>
<li>Train score models to estimate the score function of the noised up data.</li>
<li>Use the approximate score function to calculate the reverse-time SDE.</li>
</ol>
<section id="model-implementation" class="level3" data-number="5.4.1">
<h3 data-number="5.4.1" class="anchored" data-anchor-id="model-implementation"><span class="header-section-number">5.4.1</span> Model implementation</h3>
<p>To get this right, we need a score function approximator that is compatible with SDEs, i.e.&nbsp;they accept both <code>x</code> and <code>t</code> as part of the function signature and return the gradient value.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>score: <span class="bu">float</span> <span class="op">=</span> score_model(x, t) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Let’s implement it below:</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> jacfwd</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> nn</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> equinox <span class="im">as</span> eqx</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SDEFeedForwardModel1D(eqx.Module):</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Time-dependent score model.</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">    We choose an MLP here with 2 inputs (`x` and `t` concatenated),</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co">    and output a scalar which is the estimated score.</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    mlp: eqx.Module</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>,</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>        in_size<span class="op">=</span><span class="dv">2</span>,</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>        out_size<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>        width_size<span class="op">=</span><span class="dv">256</span>,</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>        depth<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>        activation<span class="op">=</span>nn.softplus,</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>        key<span class="op">=</span>random.PRNGKey(<span class="dv">45</span>),</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>    ):</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.mlp <span class="op">=</span> eqx.nn.MLP(</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>            in_size<span class="op">=</span>in_size,</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>            out_size<span class="op">=</span>out_size,</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>            width_size<span class="op">=</span>width_size,</span>
<span id="cb19-27"><a href="#cb19-27" aria-hidden="true" tabindex="-1"></a>            depth<span class="op">=</span>depth,</span>
<span id="cb19-28"><a href="#cb19-28" aria-hidden="true" tabindex="-1"></a>            activation<span class="op">=</span>activation,</span>
<span id="cb19-29"><a href="#cb19-29" aria-hidden="true" tabindex="-1"></a>            key<span class="op">=</span>key,</span>
<span id="cb19-30"><a href="#cb19-30" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb19-31"><a href="#cb19-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-32"><a href="#cb19-32" aria-hidden="true" tabindex="-1"></a>    <span class="at">@eqx.filter_jit</span></span>
<span id="cb19-33"><a href="#cb19-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x: <span class="bu">float</span>, t: <span class="bu">float</span>):</span>
<span id="cb19-34"><a href="#cb19-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Forward pass.</span></span>
<span id="cb19-35"><a href="#cb19-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-36"><a href="#cb19-36" aria-hidden="true" tabindex="-1"></a><span class="co">        :param x: Data. Should be of shape (1, :),</span></span>
<span id="cb19-37"><a href="#cb19-37" aria-hidden="true" tabindex="-1"></a><span class="co">            as the model is intended to be vmapped over batches of data.</span></span>
<span id="cb19-38"><a href="#cb19-38" aria-hidden="true" tabindex="-1"></a><span class="co">        :returns: Estimated score of a Gaussian.</span></span>
<span id="cb19-39"><a href="#cb19-39" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb19-40"><a href="#cb19-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(x, <span class="bu">float</span>) <span class="kw">or</span> x.ndim <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb19-41"><a href="#cb19-41" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> np.array([x])</span>
<span id="cb19-42"><a href="#cb19-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(t, <span class="bu">float</span>) <span class="kw">or</span> x.ndim <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb19-43"><a href="#cb19-43" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> np.array([t])</span>
<span id="cb19-44"><a href="#cb19-44" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.array([x.squeeze(), t.squeeze()])</span>
<span id="cb19-45"><a href="#cb19-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.mlp(x).squeeze()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are a few design notes for the model above that we’d like to note.</p>
<p>Firstly, note how its structure is essentially identical to the neural net score model from before, i.e.&nbsp;a multi-layer perceptron, except that now it takes in both <code>x</code> and <code>t</code> as its inputs. This is important because we are no longer interested in a discrete score model, with one per time point. Instead, we are interested in a score model that can estimate the score function of our noised up data at any time point along the SDE-based continuous-time noising function.</p>
<p>Let’s now instantiate the model:</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> SDEFeedForwardModel1D(</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    width_size<span class="op">=</span><span class="dv">256</span>, depth<span class="op">=</span><span class="dv">2</span>, activation<span class="op">=</span>nn.softplus, key<span class="op">=</span>random.PRNGKey(<span class="dv">55</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="loss-function" class="level3" data-number="5.4.2">
<h3 data-number="5.4.2" class="anchored" data-anchor-id="loss-function"><span class="header-section-number">5.4.2</span> Loss function</h3>
<p>Now, we need to calculate the loss for a batch of data. As with before, we need a score-matching loss for each noise level (i.e.&nbsp;for each <code>t</code>). In here, we have the model’s dependence on time (i.e.&nbsp;noise level) encoded as part of the model structure.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> score_models.losses.sde <span class="im">import</span> score_matching_loss <span class="im">as</span> sde_score_matching_loss, joint_score_matching_loss <span class="im">as</span> sde_joint_score_matching_loss</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(getsource(sde_score_matching_loss))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>def score_matching_loss(
    model: Union[eqx.Module, Callable], noised_data: np.ndarray, t: float
) -&gt; float:
    """Score matching loss for SDE-based score models.

    :param model: Equinox model.
    :param noised_data: Batch of data from 1 noise scale of shape (batch, n_data_dims).
    :param t: Time in SDE at which the noise scale was evaluated.
    :returns: Score matching loss for one batch of data.
    """
    model = partial(model, t=t)
    dmodel = jacfwd(model, argnums=0)
    term1 = vmap(dmodel)(noised_data)
    if term1.ndim &gt; 1:
        term1 = vmap(np.diagonal)(term1)
    term2 = 0.5 * vmap(model)(noised_data) ** 2
    inner_term = term1 + term2
    summed_by_dims = vmap(np.sum)(inner_term)
    return np.mean(summed_by_dims)
</code></pre>
</div>
</div>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(getsource(sde_joint_score_matching_loss))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>@eqx.filter_jit
def joint_score_matching_loss(
    model: Union[eqx.Module, Callable], noised_data_all: np.ndarray, ts: np.ndarray
):
    """Joint score matching loss.

    :param model: An equinox model.
    :param noised_data_all: An array of shape (time, batch, n_data_dims).
    :param ts: An array of shape (time,).
    :returns: Score matching loss, summed across all noise scales.
    """
    loss_score = 0
    for noise_batch, t in zip(noised_data_all, ts):
        scale = t
        loss_score += score_matching_loss(model, noise_batch, t) * scale
    return loss_score
</code></pre>
</div>
</div>
</section>
<section id="train-score-model" class="level3" data-number="5.4.3">
<h3 data-number="5.4.3" class="anchored" data-anchor-id="train-score-model"><span class="header-section-number">5.4.3</span> Train score model</h3>
<p>Now, let’s train the score model on our noised up data. Below, we have our training loop.</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> optax</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm.auto <span class="im">import</span> tqdm</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> score_models.losses <span class="im">import</span> joint_sde_score_matching_loss, sde_score_matching_loss</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> SDEFeedForwardModel1D(key<span class="op">=</span>random.PRNGKey(<span class="dv">55</span>))</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>optimizer <span class="op">=</span> optax.chain(</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    optax.adam(<span class="fl">5e-4</span>),</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># optax.clip(1e-6)</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>opt_state <span class="op">=</span> optimizer.init(eqx.<span class="bu">filter</span>(model, eqx.is_array))</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>dloss <span class="op">=</span> eqx.filter_jit(eqx.filter_value_and_grad(joint_sde_score_matching_loss))</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>n_steps <span class="op">=</span> <span class="dv">13_000</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>iterator <span class="op">=</span> tqdm(<span class="bu">range</span>(n_steps))</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>loss_history <span class="op">=</span> []</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>updated_score_model <span class="op">=</span> model</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> step <span class="kw">in</span> iterator:</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>    loss_score, grads <span class="op">=</span> dloss(updated_score_model, noising_ys.T, ts_noising)</span>
<span id="cb25-22"><a href="#cb25-22" aria-hidden="true" tabindex="-1"></a>    updates, opt_state <span class="op">=</span> optimizer.update(grads, opt_state)</span>
<span id="cb25-23"><a href="#cb25-23" aria-hidden="true" tabindex="-1"></a>    updated_score_model <span class="op">=</span> eqx.apply_updates(updated_score_model, updates)</span>
<span id="cb25-24"><a href="#cb25-24" aria-hidden="true" tabindex="-1"></a>    iterator.set_description(<span class="ss">f"Score: </span><span class="sc">{</span>loss_score<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb25-25"><a href="#cb25-25" aria-hidden="true" tabindex="-1"></a>    loss_history.append(<span class="bu">float</span>(loss_score))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"31409bb0c3ca4b87b3d767bae670e63d","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<p>Let’s also make sure that the model training has converged.</p>
<div class="cell" data-execution_count="22">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>plt.plot(loss_history)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Iteration"</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Loss Score"</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-training-loss-curve" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-training-loss-curve-output-1.png" width="604" height="429" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.8: Training loss curve for our continuous-time score model.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sanity-check-score-estimators-match-up-with-alternate-calculation" class="level3" data-number="5.4.4">
<h3 data-number="5.4.4" class="anchored" data-anchor-id="sanity-check-score-estimators-match-up-with-alternate-calculation"><span class="header-section-number">5.4.4</span> Sanity-check: score estimators match up with alternate calculation</h3>
<p>Because we started with Gaussian noise and expanded the noise outwards, we still have Gaussians. Let’s check that the scores match a Gaussian’s score fitted onto the marginal distributions at each timepoint.</p>
<div class="cell" data-execution_count="23">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax.scipy.stats <span class="im">import</span> norm </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> jax <span class="im">import</span> grad </span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(nrows<span class="op">=</span><span class="dv">6</span>, ncols<span class="op">=</span><span class="dv">3</span>, figsize<span class="op">=</span>(<span class="fl">8.5</span>, <span class="dv">11</span>))</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> t, noised_ys, ax <span class="kw">in</span> <span class="bu">zip</span>(ts_noising, noising_ys.T, axes.flatten()):</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>    plt.sca(ax)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    noised_ys_mu <span class="op">=</span> np.mean(noised_ys)</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>    noised_ys_sigma <span class="op">=</span> np.std(noised_ys)</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>    logp_func <span class="op">=</span> partial(norm.logpdf, loc<span class="op">=</span>noised_ys_mu, scale<span class="op">=</span>noised_ys_sigma)</span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    np.<span class="bu">sum</span>(logp_func(noised_ys))</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    dlogp_func <span class="op">=</span> grad(logp_func)</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    support <span class="op">=</span> np.linspace(noised_ys_mu <span class="op">-</span> noised_ys_sigma <span class="op">*</span> <span class="dv">3</span>, noised_ys_mu <span class="op">+</span> noised_ys_sigma <span class="op">*</span> <span class="dv">3</span>, <span class="dv">1000</span>)</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>    estimated_score <span class="op">=</span> vmap(dlogp_func)(support)</span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>    approximated_score <span class="op">=</span> vmap(partial(updated_score_model, t<span class="op">=</span>t))(support)</span>
<span id="cb27-19"><a href="#cb27-19" aria-hidden="true" tabindex="-1"></a>    plt.plot(support, estimated_score, color<span class="op">=</span><span class="st">"blue"</span>, label<span class="op">=</span><span class="st">"estimated"</span>)</span>
<span id="cb27-20"><a href="#cb27-20" aria-hidden="true" tabindex="-1"></a>    plt.plot(support, approximated_score, color<span class="op">=</span><span class="st">"red"</span>, label<span class="op">=</span><span class="st">"approximated"</span>)</span>
<span id="cb27-21"><a href="#cb27-21" aria-hidden="true" tabindex="-1"></a>    plt.xlabel(<span class="st">"Support"</span>)</span>
<span id="cb27-22"><a href="#cb27-22" aria-hidden="true" tabindex="-1"></a>    plt.ylabel(<span class="st">"Score"</span>)</span>
<span id="cb27-23"><a href="#cb27-23" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="ss">f"t=</span><span class="sc">{</span>t<span class="sc">:.2f}</span><span class="ss">"</span>)</span>
<span id="cb27-24"><a href="#cb27-24" aria-hidden="true" tabindex="-1"></a>    plt.tight_layout()</span>
<span id="cb27-25"><a href="#cb27-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-26"><a href="#cb27-26" aria-hidden="true" tabindex="-1"></a>plt.sca(axes.flatten()[<span class="dv">0</span>])</span>
<span id="cb27-27"><a href="#cb27-27" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb27-28"><a href="#cb27-28" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-score-vs-time" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-score-vs-time-output-1.png" width="805" height="1044" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.9: Estimated (blue) vs.&nbsp;approximated (red) score functions at each time evaluation. Estimated score comes from taking the location (mean) and scale (stdev) of the observed data, while approximated score comes from the time-based score model.</figcaption>
</figure>
</div>
</div>
</div>
<p>As seen in <a href="#fig-score-vs-time">Figure&nbsp;<span>5.9</span></a>, it looks like our score model is able to approximate a time-dependent score function! The score function is least well-approximated within the region of 2 sigmas of support, even if not across the full 3 sigmas. This is encouraging. We should also note that the <code>t=4.00</code> timepoint is the least well-approximated compared to the <code>t=1.00</code> timepoint.</p>
<p>Now, we’re going to look at the reverse drift. In an SDE, the drift term dictates where the system is going to move towards in the next time step. Let’s plot the vector field evaluated at each time step <code>t</code>.</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> reverse_drift(t: <span class="bu">float</span>, y: <span class="bu">float</span>, args: <span class="bu">tuple</span>):</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    f <span class="op">=</span> constant_drift(t, y, args)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    g <span class="op">=</span> time_dependent_diffusion(t, y, args)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> updated_score_model(y, t)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> f <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> g<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> s</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s plot each of these four terms to make sure we get a good feel for what’s going on.</p>
<div class="cell" data-execution_count="25">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd </span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm.auto <span class="im">import</span> tqdm </span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot constant drift as a function of y and t.</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>ys <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">50</span>)</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>ts <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">5</span>, <span class="dv">50</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>function_evals <span class="op">=</span> []</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> yval <span class="kw">in</span> ys:</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> ts:</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>        dd <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>        dd[<span class="st">"constant_drift"</span>] <span class="op">=</span> constant_drift(y<span class="op">=</span>yval, t<span class="op">=</span>t, args<span class="op">=</span>())</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>        dd[<span class="st">"time_dependent_diffusion"</span>] <span class="op">=</span> time_dependent_diffusion(y<span class="op">=</span>yval, t<span class="op">=</span>t, args<span class="op">=</span>())</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>        dd[<span class="st">"score_approximation"</span>] <span class="op">=</span> updated_score_model(x<span class="op">=</span>yval, t<span class="op">=</span>t)</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>        dd[<span class="st">"reverse_drift"</span>] <span class="op">=</span> reverse_drift(y<span class="op">=</span>yval, t<span class="op">=</span>t, args<span class="op">=</span>())</span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>        dd[<span class="st">"y"</span>] <span class="op">=</span> (yval)</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>        dd[<span class="st">"t"</span>] <span class="op">=</span> t </span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a>        function_evals.append(dd)</span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a>columns <span class="op">=</span> [<span class="st">"constant_drift"</span>, <span class="st">"time_dependent_diffusion"</span>, <span class="st">"score_approximation"</span>, <span class="st">"reverse_drift"</span>]</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>function_df <span class="op">=</span> pd.DataFrame(function_evals)</span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> column <span class="kw">in</span> function_df.columns:</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>    function_df[column] <span class="op">=</span> function_df[column].astype(<span class="bu">float</span>)</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(nrows<span class="op">=</span><span class="dv">2</span>, ncols<span class="op">=</span><span class="dv">2</span>, figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">8</span>))</span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> ax, col <span class="kw">in</span> <span class="bu">zip</span>(axes.flatten(), columns):</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>    function_eval <span class="op">=</span> function_df[[<span class="st">"y"</span>, <span class="st">"t"</span>, col]].pivot_table(index<span class="op">=</span><span class="st">"y"</span>, columns<span class="op">=</span><span class="st">"t"</span>, values<span class="op">=</span>col)</span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a>    sns.heatmap(function_eval, ax<span class="op">=</span>ax, cmap<span class="op">=</span><span class="st">"viridis"</span>)</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a>    ax.set_title(col)</span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a>    ax.set_xticklabels([<span class="ss">f"</span><span class="sc">{</span><span class="bu">float</span>(i._text)<span class="sc">:.2f}</span><span class="ss">"</span> <span class="cf">for</span> i <span class="kw">in</span> ax.get_xticklabels()])</span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a>    ax.set_yticklabels([<span class="ss">f"</span><span class="sc">{</span><span class="bu">float</span>(i._text)<span class="sc">:.2f}</span><span class="ss">"</span> <span class="cf">for</span> i <span class="kw">in</span> ax.get_yticklabels()])</span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a>sns.despine()</span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-reverse-sde-components" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-reverse-sde-components-output-1.png" width="756" height="757" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.10: Heatmap of each of the component functions in reverse_drift.</figcaption>
</figure>
</div>
</div>
</div>
<ul>
<li><code>constant_drift</code> is always 0, so no problem.</li>
<li><code>time_dependent_diffusion</code> shows how diffusion increases over time, independent of the value of <code>y</code>, which is also correct, so no problem.</li>
<li><code>score_approximation</code> shows how the Gaussian score approximator gives a gradient that is positive-valued when <code>y</code> is negative and vice versa, which pushes us towards region of high density. Also correct.</li>
<li><code>reverse_drift</code> shows us something interesting. We will end up with exploding values because +ve values drift more positive, while -ve values drift more -ve, until we hit very small time steps, and then we have no directional drift.</li>
</ul>
<p>Now, we could, in theory, run the SDE in reverse, but in my own testing of the equations, I found that I would encounter numerical stability issues. Because of the positive and negative drift zones in the reverse drift, we would end up getting extremely large negative or positive numbers. Hence, I skipped over solving the reverse SDE and instead went straight to probability flow ODEs, which are the very, very exciting piece of this entire body of work.</p>
</section>
</section>
<section id="probability-flow-odes" class="level2" data-number="5.5">
<h2 data-number="5.5" class="anchored" data-anchor-id="probability-flow-odes"><span class="header-section-number">5.5</span> Probability Flow ODEs</h2>
<p>Now that we’ve recapped what an ODE is, and have seen what SDEs can do for noising up our data, we can move on to probability flow ODEs. Why are these important? It’s because probability flow ODEs provide a deterministic mapping from our noise distribution to our data distribution and vice versa. In doing so, we can basically get rid of Langevin dynamics sampling and replace it entirely with a probability flow ODE instead. Before we go on, though, let’s take a quick look the key ODE that we need to solve:</p>
<p><span class="math display">\[dx = [f(x,t) - \frac{1}{2} g^2(t) \nabla_x \log p_t (x)] dt\]</span></p>
<p>Just like the SDE above, the terms carry the same meaning:</p>
<blockquote class="blockquote">
<ul>
<li><span class="math inline">\(f(x, t)\)</span> is a drift function that produces a vector output,</li>
<li><span class="math inline">\(g(t)\)</span> is a diffusion function that produces a scalar output,</li>
<li><span class="math inline">\(\nabla_x \log p_t (x)\)</span> is the score function, also replaceable by our neural net approximator</li>
<li>and <span class="math inline">\(dw\)</span> is infinitesimal white noise.</li>
</ul>
<p>(paraphrased from Yang’s blog)</p>
</blockquote>
<p>Now, if you study this carefully… the drift term is <em>exactly</em> the drift term we defined above! That means if we solve for the reverse drift ODE, we will get a path traced from the noise distribution back to the orginal data distribution! Let’s see that in action.</p>
<div class="cell" data-execution_count="26">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>ode_combined <span class="op">=</span> ODE(reverse_drift)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>ode <span class="op">=</span> ode_combined</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>ts <span class="op">=</span> np.linspace(<span class="dv">5</span>, <span class="dv">0</span>, <span class="dv">1000</span>)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>key <span class="op">=</span> random.PRNGKey(<span class="dv">55</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>y0s <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">5</span> ,<span class="dv">5</span>, <span class="dv">10</span>)</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> y0 <span class="kw">in</span> y0s:</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    ys <span class="op">=</span> ode(ts, y0)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    plt.plot(ts, ys)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"t"</span>)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"y"</span>)</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>plt.gca().invert_xaxis()</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>sns.despine()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-prob-flow-ode" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="04-diffeq_files/figure-html/fig-prob-flow-ode-output-1.png" width="587" height="429" class="figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5.11: Probability flow ODE from noise distribution (t=5) back to original data (t=0).</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="generalizing-to-a-mixture-distribution" class="level2" data-number="5.6">
<h2 data-number="5.6" class="anchored" data-anchor-id="generalizing-to-a-mixture-distribution"><span class="header-section-number">5.6</span> Generalizing to a Mixture Distribution</h2>
<p>Thus far, we saw a probability flow ODE in action for a univariate, unimodal distribution. Let’s see if we can make the thing work for a mixture distribution.</p>
<section id="generate-mixture-data" class="level3" data-number="5.6.1">
<h3 data-number="5.6.1" class="anchored" data-anchor-id="generate-mixture-data"><span class="header-section-number">5.6.1</span> Generate Mixture Data</h3>
<p>We will start by generating a mixture Gaussian dataset.</p>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>mu1, sigma1 <span class="op">=</span> <span class="op">-</span><span class="fl">2.0</span>, <span class="fl">1.0</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>mu2, sigma2 <span class="op">=</span> <span class="fl">2.0</span>, <span class="fl">0.5</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>k1, k2 <span class="op">=</span> random.split(key)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>comp1 <span class="op">=</span> random.normal(k1, shape<span class="op">=</span>(<span class="dv">1000</span>,)) <span class="op">*</span> sigma1 <span class="op">+</span> mu1 </span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>comp2 <span class="op">=</span> random.normal(k2, shape<span class="op">=</span>(<span class="dv">1000</span>,)) <span class="op">*</span> sigma2 <span class="op">+</span> mu2</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> np.concatenate([comp1, comp2])</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>plt.hist(data, bins<span class="op">=</span><span class="dv">100</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="04-diffeq_files/figure-html/cell-28-output-1.png" width="566" height="411"></p>
</div>
</div>
<p>And just like that, we have:</p>
<ul>
<li>An SDE that noises up data (forward-time),</li>
<li>A score model that estimates the score of the data, and</li>
<li>A probability flow ODE that maps from noise back to data (reverse-time).</li>
</ul>
<p>That last point is the coolest of them all, in my opinion. Previously, we used Langevin dynamics sampling to sample out new sequences. While random sampling is simple, it also aesthetically felt less elegant than what we have with an ODE. The key ingredients here are:</p>
<ul>
<li>A time-dependent score model that can calculate (or estimate) the score of our noised distribution,</li>
<li>The known noise generator “diffusion” function, and</li>
<li>The known drift function,</li>
</ul>
<p>and all we need to do is solve a neural ODE while reversing time. Then, by drawing new coordinates from the noise distribution, we can deterministically map them back to the original data space!</p>
</section>
</section>
<section id="references" class="level2" data-number="5.7">
<h2 data-number="5.7" class="anchored" data-anchor-id="references"><span class="header-section-number">5.7</span> References</h2>


<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-JMLR:v6:hyvarinen05a" class="csl-entry" role="listitem">
Hyvärinen, Aapo. 2005. <span>“Estimation of Non-Normalized Statistical Models by Score Matching.”</span> <em>Journal of Machine Learning Research</em> 6 (24): 695–709. <a href="http://jmlr.org/papers/v6/hyvarinen05a.html">http://jmlr.org/papers/v6/hyvarinen05a.html</a>.
</div>
</div>
</section>

</main> <!-- /main -->
<script type="application/vnd.jupyter.widget-state+json">
{"state":{"31409bb0c3ca4b87b3d767bae670e63d":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HBoxModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HBoxModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HBoxView","box_style":"","children":["IPY_MODEL_81842c712bc04a13bed745f45ecc0efa","IPY_MODEL_714794e0d12947f3b6045e80f639edaf","IPY_MODEL_32937f3e8fdd4eafacb9c7c30114cc0d"],"layout":"IPY_MODEL_8452cfb897a84894bff4e9870d494e55","tabbable":null,"tooltip":null}},"32937f3e8fdd4eafacb9c7c30114cc0d":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HTMLView","description":"","description_allow_html":false,"layout":"IPY_MODEL_7256c2a6cdc94757ad16608115410f34","placeholder":"​","style":"IPY_MODEL_e024eb3252c2413e8d06125838955361","tabbable":null,"tooltip":null,"value":" 13000/13000 [19:26&lt;00:00, 11.37it/s]"}},"3fd3ed22fc1e42c5ab8f7ddcb1c55b0f":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"60ef8c846d8f44a88fbc016217f73f3e":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"ProgressStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"ProgressStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","bar_color":null,"description_width":""}},"714794e0d12947f3b6045e80f639edaf":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"FloatProgressModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"FloatProgressModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"ProgressView","bar_style":"success","description":"","description_allow_html":false,"layout":"IPY_MODEL_3fd3ed22fc1e42c5ab8f7ddcb1c55b0f","max":13000,"min":0,"orientation":"horizontal","style":"IPY_MODEL_60ef8c846d8f44a88fbc016217f73f3e","tabbable":null,"tooltip":null,"value":13000}},"7256c2a6cdc94757ad16608115410f34":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"81842c712bc04a13bed745f45ecc0efa":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HTMLView","description":"","description_allow_html":false,"layout":"IPY_MODEL_c5147b828848459cb225a4ff984737d8","placeholder":"​","style":"IPY_MODEL_d473f99718e8479c8b178edde56e4801","tabbable":null,"tooltip":null,"value":"Score: -96.97: 100%"}},"8452cfb897a84894bff4e9870d494e55":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"c5147b828848459cb225a4ff984737d8":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"d473f99718e8479c8b178edde56e4801":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","background":null,"description_width":"","font_size":null,"text_color":null}},"e024eb3252c2413e8d06125838955361":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","background":null,"description_width":"","font_size":null,"text_color":null}}},"version_major":2,"version_minor":0}
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../notebooks/03-noise-scales.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Noise Scales</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../notebooks/05-generalizing-2d.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Generalizing to Higher Dimensions</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">Copyright 2022-present, Eric J. Ma</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>



</body></html>